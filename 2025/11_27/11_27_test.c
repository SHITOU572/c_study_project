#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<windows.h>
#include<string.h>
#include<assert.h>


//深剖数据在内存中的存储

///1.数据类型(char-1、short-2、int-4 、long-4(X86)/8(X64)[sizeof(long)>=sizeof(int)]、long long-8、float-4、double-8)
//类型的意义：1、这个类型开辟的空间大小		2、看待内存的视角
// 
//整形(可在头文件limits.h中查看)：
//char(字符的本质是ASCII码值，是整型，划分为整型)	(char --> ?  标准为定义，取决于编译器的实现)
//  unsignedchar		signed char		char
//short
//  unsigned short		signed short
//int(int --> signed int)
//  unsigned int		signed int
//long
//  unsigned long		signed long
//long long
//  unsigned long long	signed long long
// 
//浮点型：
// float精度低，存储的数值范围小,double的精度高，存储的数据范围更大
//float
//double
// 
//构造类型(自定义类型)：
//数组类型
//结构体类型(struct)
//枚举类型(enum)
//联合类型(union)
//
//指针类型：
//int* pi
//char* pc
//float* pf
//void* pv
//
//空类型：
//void(无类型，用于函数的返回值、函数参数、指针类型)

////2.整数在内存中存储
// 
//// 整数在内存中存放的是补码的二进制序列(为了加法和减法一致处理，CPU只有加法器;补码原码相互转换不用额外的硬件电路)
// 1-1 ->1+(-1)
// 00000000000000000000000000000001+11111111111111111111111111111111=00000000000000000000000000000000(最高位0丢了)
// 
//数值有不同的表示形式
// 2进制：0b10101
// 8进制：025
// 10进制：21
// 16进制：0x15
//
//整数的二进制有三种表示形式(符号位+数值位)
// 正数的原码、反码、补码相同
// 负数的原码、反码、补码需计算
//1.原码
//2.反码：按位取反
//3.补码：反码+1
// 原码->取反->反码->+1->补码
// 补码->取反->反码->+1->原码
//4个二进制位 -> 1个16进制位(32 -> 8)0x00 00 00 14 -> 14 00 00 00
//存储的是二进制(补码)，但展示16进制
//
////大小端(一个数据在内存中的存储方式，正or逆序？)
//0x11 22 33 44(高位字节数 -> 低位字节数)
//				低地址			高地址
// 大端【字节序】存储：11 22 33 44
// (高位 -> 低地址	低位 -> 高地址)
// 如：VS...
// 小端【字节序】存储：44 33 22 11
// (低位 -> 低地址	高位 -> 高地址)
// 如：KEIL C51...
// ***栈内存：先使用高地址
// 《深入理解计算机系统》
//
// 编写程序，判断大小端
// 法一：
//int main()
//{
//	int a = 1;
//	if (*((char*)&a) == 1)//char - 一个字节，char* - 地址，解引用 - 看值
//		printf("小端\n");
//	else
//		printf("大端\n");
//
//	return 0;
//}
//法二：
//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//
//	return 0;
//}

////练习
//
//T1.-1 -1 255
//int main()
//{
//	char a = -1;//char在大多数编译器里是signed char(但是C语言标准并没有规定char)
//	signed char b = -1;
//	//signed char:-128~127(符号位+数值位)
//	//1000 0000 -> -128(这个算不了，进位了，直接解-128)
//	unsigned char c = -1;
//	//unsined char:0~255(数值位)
//	//1000 0000 0000 0000 0000 0000 0000 0001 - 原码
//	//1111 1111 1111 1111 1111 1111 1111 1110 - 反码
//	//1111 1111 1111 1111 1111 1111 1111 1111 - 补码
//	//由于char类型，截断最后8个二进制序列 - 1111 1111	(数据存储时，截断低位)
//	//0000 0000 0000 0000 0000 0000 1111 1111 - 整型提升(类型小于int),高位补零(unsigned类型)
//	//即：255
//	// char和signed char同理
//	printf("%4.d%4.d%4.d\n", a, b, c);
//
//	//同理：short(signed short[-32768~32767];unsigned short[0~65535]),int...
//
//	return 0;
//}
//
//T2.4294967168 -128
//int main()
//{
//	char a = -128;
//	//1000 0000 - a(截断后)
//	//1111 1111 1111 1111 1111 1111 1000 0000 - 提升
//	printf("%u\n", a);//4294967168
//	//%u - 打印无符号整数
//	printf("%d\n", a);//-128
//
//	return 0;
//}
//
//T3.4294967168
//int main()
//{
//	char a = 128;
//  //0000 0000 0000 0000 0000 0000 1000 0000
//	//1000 0000 - a(截断后)
//	//1111 1111 1111 1111 1111 1111 1000 0000
//	printf("%u\n", a);//4294967168
//
//	return 0;
//}
//
//T4.-10
//int main()
//{
//	int i = -20;
//	//1000 0000 0000 0000 0000 0000 0001 0100 - 原
//	//1111 1111 1111 1111 1111 1111 1110 1011 - 反
//	//1111 1111 1111 1111 1111 1111 1110 1100 - 补
//	unsigned int j = 10;
//	//0000 0000 0000 0000 0000 0000 0000 1010 - 补
//	
//	//1111 1111 1111 1111 1111 1111 1111 0110 - 原
//	//1000 0000 0000 0000 0000 0000 0000 1001 - 反
//	//1000 0000 0000 0000 0000 0000 0000 1010 - 补
//	printf("%d\n", i + j);//-10
//
//	return 0;
//}
//
//T5.死循环
//int main()
//{
//	unsigned int i;
//	for (i = 9;i >= 0;i--)
//	{
//		printf("%u\n", i);//*-1 -> 4294967295(%u - 无符号位[i >= 0])
//		Sleep(1000);//休眠1000毫秒
//	}
//
//	return 0;
//}
//
//T6.255
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0;i < 1000;i++)
//	{
//		a[i] = -1 - i;
//	}
//	//-1 -2 -3 ... -1000?
//	//arr[i] -->char  -128~127
//	printf("%d", strlen(a));//-1...-128 127...1 0(128+127=255)
//	//strlen:求字符串长度，关注的是字符串中"\0"(数字0)之前出现了多少字符
//
//	return 0;
//}
//
//T7.死循环
//unsigned char i = 0;
////unsigned char:0~255
//int main()
//{
//	for (i = 0;i <= 255;i++)
//	{
//		printf("hello world\n");
//	}
//
//	return 0;
//}
// 
//***无符号数很容易写出死循环，小心
// 
//int my_strlen(const char* str)
//{
//	assert(str);
//	int count = 0;
//	while (*str)
//	{
//		str++;
//		count++;
//	}
//	return count;
//}
//int main()
//{
//	/*int len = strlen("abcdef");
//	printf("%d\n", len);*/
//	
//	if (strlen("abc") - strlen("abcdef") >= 0)//strlen(size_t -> unsigned int)
//		//if(strlen("abc")>=strlen("abcdef"))
//		printf(">\n");
//	else
//		printf("<\n");
//
//	return 0;
//}
