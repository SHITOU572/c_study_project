#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//Git:
//仓库：本地仓库(本地电脑创建的仓库)	远程仓库(保存了所有文件、版本记录和历史信息)[如：github、码云……]
//工作目录{工作区}(正在编辑文件的所在的地方)[对文件进行的修改都发生在工作目录中]	暂存区(临时存放区)[记录准备提交的文件的修改]
//工作目录(属于工作区)-->git add-->暂存区(属于仓库)-->git commit-->本地仓库(属于仓库)

//master(或言main):默认的主分支

//Git的三个主要的配置文件：
//1、系统全局配置(system):包含系统内所有用户和所有仓库的配置信息(Git\etc\giytconfig)
//2、用户全局配置(global):当前用户的所有的Git仓库配置(User\[系统用户名]\.gitconfig)
//3.仓库配置(local)[仅适用于某个Git仓库]:(项目根目录/.git/config)
//优先级：local>global>system
// 
//查看当前Git配置的所有信息
//git config --list
//git config -l
//
//查看系统全局配置
//git config --system--list
//
//查看当前用户全局配置
//git config--glabal--list
//
//查看当前仓库配置信息
//git config--local--list

//配置Git(用户名+邮箱地址)
//(全局)用户名：git config --global user.name "SHITOU"	||也可改成local--项目
//(全局)邮箱地址：git config --global user.email "50747383@qq.com"	||**注意：在name和email后面加空格！！！

//Git基本操作
//1、初始化(git)项目仓库:1.创建本地仓库  2.克隆远程仓库
//git init    ||创建一个隐藏的.git文件夹(存储所有的版本控制信息：历史记录、配置信息……)
//
//    git status    ||查看当前状态
// 
//2、添加文件到Git仓库中，并开始版本控制
//git add .   ||添加所有文件
//git add filename   ||添加特定文件  
//
//git commit   ||将暂存区内容提交到本地仓库
//git commit -a  || 直接从工作区提交到本版库，跳过git add步骤，不包括新增文件 
//git commit --amend -m "描述本次修改内容"  || 使用一次新的commit，替代上一次提交，会修改commit的hash值(id)
// 
//3、Git为每个提交创建一个独立的版本历史纪录(id+描述+快照内容)
// id:用摘要算法(SHA1)-->40不重复字符(保证唯一性 完整性)  本地指令可以只用前几位(6) 可通过id找到层级的任何内容和变动
//描述:针对本次提交的描述说明，准确填写
//快照：完整的版本文件，(对象树的结构)存在(.git\objects)
//
// 4、
//git log	||查看提交历史(id+作者+时间+提交信息)
//git log -n20	||查看日志(最近20条)，不带参数-n则显示所有日志
//git log -n20 --oneline	||参数"--oneline"可以让日志输出更简洁(1行)
//git log -n20 --graph	||参数"--graph"可视化显示分支关系
//git log --follow [file]	||显示某个文件的版本历史

//工作区->"git add"->缓存区->"git commit"->仓库    仓库->"git log"->查看历史记录
//工作区->"git commit -a"->仓库

//5、查看文件变更
//git diff	||显示工作目录和暂存区之间的差异
//
//git pull <远程仓库名> <远程分支名>	||远程仓库-->本地仓库
//git pull <origin(默认的远程仓库名)> <main/master(远程仓库的分支)>	||远程仓库-->本地仓库
//git pull oringin main
// git pull	||省略--从当前所关联的分支的远程仓库和分支中拉取更新
// 

//git push <远程仓库名> <本地分支名>:<远程分支名>	||本地仓库的更改-->远程仓库
//git push origin 要推送的本地分支名称:希望推送到的远程分支名
//git push	||省略--从你当前分支 推送到 对应的远程仓库分支
// 
// 
// 分支：可以隔离开发过程，在不同分支上开法而不影响主分支(main/master)
//		 一般用于开发新功能和修复bug
//master:主分支--创建仓库时就存在，存放稳定的代码(开发后测试通过的代码)，不允许随便修改和合并
//开发分支：团队日常使用，在该分支上进行，不影响主分支的稳定
// 功能A分支：开发人员A根据自己需求，创建的临时分支，开发完毕后，合并到开发分支，并删除该分支
// 
//创建分支：
//git branch 分支名		||创建“分支名”的分支
//git branch	||查看当前仓库的所有分支
//git checkout 分支名	||切换到“分支名”的分支
//git switch 分支名		||同上
//
//git merge 要合并的文件	
// 如果出现冲突		即出现"both modified:		new-feature.cpp"的字样
// 需要我们手动处理
//打开冲突文件
// 
//	<<<<<HEAD
//	主分支内容(main分支的内容)	||当前分支内容
//	=======
//	新功能分支的内容(new-feature分支的内容)		||将合并的分支的内容
//	>>>>>>new-feature
//
//手动删除修改，保留所需内容，并删除冲突标记
//add-->commit
//
//git branch -d 分支名	||删除分支	
// ***注意：用"-d"删除分支时，要确定分支已经合并到主分支
// git branch -D 分支名	||强制删除分支
// 
//
//Git标签(tag)
//tag(相当于：仓库中某个重要提交的书签//也代表着一个稳定发布或里程碑性质的版本):用与标记项目中的某个重要的版本或者关键节点
//引用场景：项目正式发布版本、发布测试版本或Beta版本、记录项目的重要节点或里程碑、
//
//创建标签:	
//本地标签
//1、轻量标签：简单记录某个提交
//git tag <标签名>	||指向最新的commit
//2、附注标签:携带说明信息的tag，有额外的附注信息
//git tag -a <标签名> -m "标签说明"		||"-a"==>创建带注释的标签   "-m"==>具体的标签描述
//
//git tag -a <标签名> <commit的哈希值> -m "标签说明"	||给过去的commit打标签
//git tag	||查看标签(按字母数字顺序排列)
//git show <标签名>		||查看具体详细的标签信息
//
//本地标签<--push-->远程仓库
//1、推送单个标签
//git push oringin <标签名>
//2、推送全部标签
//git push origin --tags
//
//删除标签
//git tag -d <标签名>	||删除本地标签，但远程标签依然存在
// git push origin --delete <标签名>	||删除远程标签

//撤销与恢复
// 
//git checkout	||撤回在工作目录中的文件
//git checkout -- <文件名>	||恢复该文件到上次提交的状态
//git reset	<文件名>||移除在暂存区的文件，但文件的修改任保留在工作目录中	且代码任然存在，只不过没在暂存区，没提交
//
//撤回已提交文件

//1、git reset：移动指针撤销	||回退或撤销本地提交，可以将分支的提交历史往回移动(3种模式)
//git reset --soft	||仅撤销提交，代码在暂存区	保留修改	保留暂存区	移动
//git reset --mixed	||撤销提交及暂存			保留修改	清空暂存区	移动	||默认模式，mixed可省略
//git reset --mixed v1.0	||可也撤销标签
//git reset --hard	||撤销提交及所有修改		丢弃修改	清空		移动
//git reset --hard 221fda	||还可以撤销id
//示例
//git rsert --soft HEAD~1	||GEAD--最新提交	HEAD~1--最新提交的前一个提交	……
//
//未推送远程仓库：放心使用git reset 撤销
//已推送远程仓库：不建议使用git reset 撤销
//
// 
//2、git revert：创建一个新的提交，撤销某个历史提交的修改	||不会改变提交历史，团队协作更安全 
//git revert <要撤销的commit哈希值>
// ***也可以撤销标签、id
//
//git reset								git revet
//会改变历史							保留提交历史记录，不改变已有的提交历史
//不推荐用于已推送的远程仓库			推荐用于远程仓库
//使用不当可能丢弃代码					更安全，不丢失代码
//回退到指定提交，直接修改HEAD指针位置	新创建一次提交来抵消原提交的修改
//
//未推送到远程的本地撤销或撤销提交		git reset --soft /git reset --mixed
//已推送到远程或多人协作的场景			git revert
//彻底丢弃最新修改(未推送到远程)		谨慎使用git reset --hard

//Git Flow:(1h9min30s)
// 主分支(main/master)：稳定代码分支,不允许直接push代码，只能请求合并pull request,且只接受hotfix release分支的代码合并
// 热修复分支(hotfix)：针对线上紧急问题，bug修复，修复完毕后合并到主分支、开发分支
// 发布分支(release):迭代版本发布，迭代开发完成，合并develop代码到release上
// 开发分支(develop)：针对迭代任务开发，日常开发原则上都在此分支上，迭代完成后合并到release分支上
// 功能分支(feature):开发人员自己创建的本地分支，用于开发具体的新功能，开发完成后，合并到develop,后删除





//指针和指针类型(本质上 指针是地址)
//指针：1、内存中最小单元的编号，即地址(内存-8G/16G   内存空间如何管理？	切割成内存单元 - 1byte - 8bits)
//		2、口语的指针：指针变量，用于存放内存地址的变量
//		3、指针变量是用来的存放地址的，地址是唯一标示一块地址空间的
//		4、指针大小：在32位(X86)机器中4byte,64位(X64)机器中8byte


//指针类型的意义:
// 1、不改变指针大小，但改变了解引用时，访问几个byte(有多大权限)
//	  int*--访问4byte  char*--1byte……
// 
//int main()
//{
//	int a = 0x11223344;
//	//int* pa = &a;
//	//*pa = 0;//00 00 00 00
//	char* pa = (char*) & a;
//	*pa = 0;//00 33 22 11
//
//	return 0;
//}

//2、指针类型决定了指针+-1操作时，跳过几个字节
//	 即决定了指针的步长
// 
//int main()
//{
//	int a = 0x11223344;
//	int* pa = &a;
//	char* pc = &a;
//
//	printf("pa=%p\n", pa);
//	printf("pa+1=%p\n", pa+1);
//
//	printf("pc=%p\n", pc);
//	printf("pc+1=%p\n", pc+1);
//
//	return 0;
//}

//int main()
//{
//	//int* 和float* 解引用访问4个字节，+-1也跳过4个字节
//	//int*和float*能否通用呢？
//
//	int a = 0;
//	int* pi = &a;
//	float* pf = &a;
//	*pi = 100;//64 00 00 00
//	*pf = 100.0;//00 00 c8 42
//	
//	//不能！(因为存储的数据类型不一样，尽管解引用权限和步长一致)
//	return 0;
//}